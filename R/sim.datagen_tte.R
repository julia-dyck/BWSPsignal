#' Generate simulated time-to-event data
#'
#' Simulation of time-to-event (tte) data.
#' 
#' @param genpar A vector containing 6 numeric elements:
#' \enumerate{
#'       \item sample size \eqn{N},
#'       \item background rate \eqn{br} (observed in population on average),
#'       \item adverse drug reaction (ADR)) rate \eqn{adr} as proportion of the background rate,
#'       \item relative proportion of ADR mean time \eqn{m.rel} of the observation period (OP),
#'       \item relative standard deviation \eqn{rel.sd},
#'       \item length of the OP \eqn{censor}.
#'             }
#'
#' @return A data frame of size \eqn{N} with variables \code{time} (integer) indicating 
#' event- or censoring time and \code{status} (binary) indicating whether the event was observed or
#' the observation was censored.
#' 
#'
#' @details After specification of the input, the data simulation works as follows:
#'
#' The absolute number of events due to background causes (other than ADR) is
#' generated by a binomial distribution with probability \eqn{br}.
#' The absolute number of events caused by the ADR is generated with a
#' binomial distribution with probability \eqn{br\cdot adr}. In sum, the expected
#' number of events within the data set is \eqn{n \cdot br (1 + adr)}.
#'
#' For the \eqn{br} cases, the event-times are generated using a uniform distribution on
#' the interval \eqn{[0, censor]}. For the ADR cases, event-times are obtained from a normal
#' distribution. The mean of the normal distribution is specified as relative proportion
#' \eqn{m.rel} of the OP. 
#' The standard deviation is defined as \eqn{ rel.sd \cdot censor}. 
#' All generated event-times \eqn{\leq 0} (due to the normal distribution's support) are set to 1. 
#' All generated event-times \eqn{\geq censor} are censored retroactively. 
#' The continuous values are rounded to integer.
#' The data set is filled up with censored observations (status = 0) at time \eqn{censor}.
#' 
#' For more details, see \insertCite{dyck2024bpgwsppreprint;textual}{WSPsignal}.
#' 
#' @seealso [tte]
#'
#' @references 
#' \insertAllCited{}
#' 
#' @examples
#' sim.datagen_tte(c(100, 0.1, 1, 0.5, 0.05, 365))
#' 
#' @export



sim.datagen_tte = function(genpar){
  genpar = as.numeric(genpar)
  
  # argument checks
  if (length(genpar) != 6L) {
    stop("Argument genpar must be a vector of length 6 with finite values.")
  }
  n            = genpar[1]
  br           = genpar[2]
  adr.rate     = genpar[3]
  adr.quantile = genpar[4]
  adr.relsd    = genpar[5]
  censor       = genpar[6]
  
  if (n <= 0 || n != as.integer(n)) {
    stop("N (genpar[1]) must be a positive integer.")
  }
  
  if (br < 0 || br > 1) {
    stop("br (genpar[2]) must be in [0, 1].")
  }
  
  if (adr.rate < 0) {
    stop("adr (genpar[3]) must be >= 0.")
  }
  
  if (adr.rate > 0) {
    if (is.na(adr.quantile) || is.na(adr.relsd)) {
      stop("If adr > 0, m.rel and rel.sd must be provided (not NA).")
    }
  }
  
  if (!is.na(adr.quantile) && (adr.quantile <= 0 || adr.quantile >= 1)) {
    stop("m.rel (genpar[4]) must be in (0, 1).")
  }
  
  if (!is.na(adr.relsd) && adr.relsd <= 0) {
    stop("rel.sd (genpar[5]) must be > 0.")
  }
  
  if (censor <= 0 || censor != as.integer(censor)) {
    stop("censor (genpar[6]) must be a positive integer.")
  }
  
  if (br * adr.rate > 1) {
    stop("Invalid rates: br * adr must not exceed 1.")
  }

  # Number of br & adr cases in the study
  n.br = stats::rbinom(1,n, prob = br)
  n.adr = stats::rbinom(1,n, prob = br*adr.rate)
  # event time for background event candidates
  t.br = stats::runif(n.br, min = 0, max = censor)

  # mean time point for adr events
  m.adr = round(adr.quantile*censor)
  # standard deviation for adr event times
  sd.adr = adr.relsd*censor
  # event time for adr event candidates
  t.adr = stats::rnorm(n.adr, mean = m.adr, sd = sd.adr)
  # adjustment for negative time points
  if(sum(t.adr <= 0) > 0){
    t.adr[t.adr <= 0] = 1
  }
  # adjustment for time points after censoring
  if(sum(t.adr > censor) > 0){
    ind = which(t.adr > censor)
    t.adr = t.adr[-ind]
  }
  # number of events in the observation period
  n.events = length(c(t.br, t.adr))
  # status vector for whole sample
  status = c(rep(1,n.events), rep(0, n-n.events))
  # time vector (continuous values) for whole sample
  time = c(t.br, t.adr, rep(censor,n-n.events))
  # time vector (daily scale) for whole sample
  time = ceiling(time)
  dat = data.frame(time, status)

  return(data = dat)
}

